Vectors

+[missing] in [missing] introduces vectors.

A vector is a fixed-length array with constant-time access and update of
the vector slots, which are numbered from 0 to one less than the number
of slots in the vector.

Two vectors are equal? if they have the same length, and if the values
in corresponding slots of the vectors are equal?.

A vector can be mutable or immutable. When an immutable vector is
provided to a procedure like vector-set!, the exn:fail:contract
exception is raised. Vectors generated by the default reader (see
[missing]) are immutable.

A vector can be used as a single-valued sequence (see [missing]). The
elements of the vector serve as elements of the sequence. See also
in-vector.

A literal or printed vector starts with #(, optionally with a number
between the # and (. See [missing]     for information on reading
vectors and [missing]     for information on printing vectors.

                                        *vector?*
(vector? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a vector, #f otherwise.

                                        *make-vector*
(make-vector size [v]) -> vector? ~
  size : exact-nonnegative-integer? ~
  v : any/c = 0 ~

Returns a mutable vector with size slots, where all slots are
initialized to contain v.

                                        *vector*
(vector v ...) -> vector? ~
  v : any/c ~

Returns a newly allocated mutable vector with as many slots as provided
vs, where the slots are initialized to contain the given vs in order.

                                        *vector-immutable*
(vector-immutable v ...) -> (and/c vector? ~
                                   immutable?)
  v : any/c ~

Returns a newly allocated immutable vector with as many slots as
provided vs, where the slots are contain the given vs in order.

                                        *vector-length*
(vector-length vec) -> exact-nonnegative-integer? ~
  vec : vector? ~

Returns the length of vec (i.e., the number of slots in the vector).

                                        *vector-ref*
(vector-ref vec pos) -> any/c ~
  vec : vector? ~
  pos : exact-nonnegative-integer? ~

Returns the element in slot pos of vec. The first slot is position 0,
and the last slot is one less than (vector-length vec).

                                        *vector-set!*
(vector-set! vec pos v) -> void? ~
  vec : (and/c vector? (not/c immutable?)) ~
  pos : exact-nonnegative-integer? ~
  v : any/c ~

Updates the slot pos of vec to contain v.

                                        *vector->list*
(vector->list vec) -> list? ~
  vec : vector? ~

Returns a list with the same length and elements as vec.

                                        *list->vector*
(list->vector lst) -> vector? ~
  lst : list? ~

Returns a mutable vector with the same length and elements as lst.

                                        *vector->immutable-vector*
(vector->immutable-vector vec) -> (and/c vector? immutable?) ~
  vec : vector? ~

Returns an immutable vector with the same length and elements as vec. If
vec is itself immutable, then it is returned as the result.

                                        *vector-fill!*
(vector-fill! vec v) -> void? ~
  vec : (and/c vector? (not/c immutable?)) ~
  v : any/c ~

Changes all slots of vec to contain v.

                                        *vector-copy!*
(vector-copy!  dest            ~
               dest-start     
               src            
              [src-start      
               src-end])  -> void?
  dest : (and/c vector? (not/c immutable?)) ~
  dest-start : exact-nonnegative-integer? ~
  src : vector? ~
  src-start : exact-nonnegative-integer? = 0 ~
  src-end : exact-nonnegative-integer? = (vector-length src) ~

Changes the elements of dest starting at position  dest-start to match
the elements in src from  src-start (inclusive) to src-end (exclusive).
The  vectors dest and src can be the same vector, and in  that case the
destination region can overlap with the source region;  the destination
elements after the copy match the source elements  from before the copy.
If any of dest-start,  src-start, or src-end are out of range (taking
into  account the sizes of the vectors and the source and destination
regions), the exn:fail:contract exception is raised.

Examples:
  > (define v (vector 'A 'p 'p 'l 'e))

  > (vector-copy! v 4 #(y))

  > (vector-copy! v 0 v 3 4)

  > v
  '#(l p p l y)

                                        *vector->values*
(vector->values vec [start-pos end-pos]) -> any ~
  vec : vector? ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (vector-length vec) ~

Returns end-pos - start-pos values, which are the elements of vec from
start-pos (inclusive) to end-pos (exclusive). If start-pos or end-pos
are greater than (vector-length vec), or if end-pos is less than
start-pos, the exn:fail:contract exception is raised.

                                        *build-vector*
(build-vector n proc) -> vector? ~
  n : exact-nonnegative-integer? ~
  proc : (exact-nonnegative-integer? . -> . any/c) ~

Creates a vector of n elements by applying proc to the integers from 0
to (sub1 n) in order. If vec is the resulting vector, then (vector-ref
vec i) is the value produced by (proc i).

Example:
  > (build-vector 5 add1)
  '#(1 2 3 4 5)

1. Additional Vector Functions

 (require racket/vector) package: base ~

The bindings documented in this section are provided by the
racket/vector and racket libraries, but not racket/base.

                                        *vector-set*!*
(vector-set*! vec pos v ... ...) -> void? ~
  vec : (and/c vector? (not/c immutable?)) ~
  pos : exact-nonnegative-integer? ~
  v : any/c ~

Updates each slot pos of vec to contain each v. The update takes place
from the left so later updates overwrite earlier updates.

                                        *vector-map*
(vector-map proc vec ...+) -> vector? ~
  proc : procedure? ~
  vec : vector? ~

Applies proc to the elements of the vecs from the  first elements to the
last. The proc argument must accept  the same number of arguments as the
number of supplied vecs,  and all vecs must have the same number of
elements.  The  result is a fresh vector containing each result of proc
in  order.

Example:
  > (vector-map + #(1 2) #(3 4))
  '#(4 6)

                                        *vector-map!*
(vector-map! proc vec ...+) -> vector? ~
  proc : procedure? ~
  vec : (and/c vector? (not/c immutable?)) ~

Like vector-map, but result of proc is inserted into  the first vec at
the index that the arguments to  proc were taken from. The result is the
first vec.

Examples:
  > (define v (vector 1 2 3 4))

  > (vector-map! add1 v)
  '#(2 3 4 5)
  > v
  '#(2 3 4 5)

                                        *vector-append*
(vector-append vec ...) -> vector? ~
  vec : vector? ~

Creates a fresh vector that contains all of the elements of the given
vectors in order.

Example:
  > (vector-append #(1 2) #(3 4))
  '#(1 2 3 4)

                                        *vector-take*
(vector-take vec pos) -> vector? ~
  vec : vector? ~
  pos : exact-nonnegative-integer? ~

Returns a fresh vector whose elements are the first pos elements of vec.
If vec has fewer than pos elements, then the exn:fail:contract exception
is raised.

Example:
  > (vector-take #(1 2 3 4) 2)
  '#(1 2)

                                        *vector-take-right*
(vector-take-right vec pos) -> vector? ~
  vec : vector? ~
  pos : exact-nonnegative-integer? ~

Returns a fresh vector whose elements are the last pos elements of vec.
If vec has fewer than pos elements, then the exn:fail:contract exception
is raised.

Example:
  > (vector-take-right #(1 2 3 4) 2)
  '#(3 4)

                                        *vector-drop*
(vector-drop vec pos) -> vector? ~
  vec : vector? ~
  pos : exact-nonnegative-integer? ~

Returns a fresh vector whose elements are the elements of vec  after the
first pos elements.  If vec has fewer  than pos elements, then the
exn:fail:contract exception is raised.

Example:
  > (vector-drop #(1 2 3 4) 2)
  '#(3 4)

                                        *vector-drop-right*
(vector-drop-right vec pos) -> vector? ~
  vec : vector? ~
  pos : exact-nonnegative-integer? ~

Returns a fresh vector whose elements are the elements of vec  before
the first pos elements.  If vec has fewer  than pos elements, then the
exn:fail:contract exception is raised.

Example:
  > (vector-drop-right #(1 2 3 4) 2)
  '#(1 2)

                                        *vector-split-at*
(vector-split-at vec pos) -> vector? vector? ~
  vec : vector? ~
  pos : exact-nonnegative-integer? ~

Returns the same result as

  (values (vector-take vec pos) (vector-drop vec pos))

except that it can be faster.

Example:
  > (vector-split-at #(1 2 3 4 5) 2)
  '#(1 2)
  '#(3 4 5)

                                        *vector-split-at-right*
(vector-split-at-right vec pos) -> vector? vector? ~
  vec : vector? ~
  pos : exact-nonnegative-integer? ~

Returns the same result as

  (values (vector-take-right vec pos) (vector-drop-right vec pos))

except that it can be faster.

Example:
  > (vector-split-at-right #(1 2 3 4 5) 2)
  '#(1 2 3)
  '#(4 5)

                                        *vector-copy*
(vector-copy vec [start end]) -> vector? ~
  vec : vector? ~
  start : exact-nonnegative-integer? = 0 ~
  end : exact-nonnegative-integer? = (vector-length v) ~

Creates a fresh vector of size (- end start), with all of the elements
of vec from start (inclusive) to end (exclusive).

Examples:
  > (vector-copy #(1 2 3 4))
  '#(1 2 3 4)
  > (vector-copy #(1 2 3 4) 3)
  '#(4)
  > (vector-copy #(1 2 3 4) 2 3)
  '#(3)

                                        *vector-filter*
(vector-filter pred vec) -> vector? ~
  pred : procedure? ~
  vec : vector? ~

Returns a fresh vector with the elements of vec for which  pred produces
a true value. The pred procedure is  applied to each element from first
to last.

Example:
  > (vector-filter even? #(1 2 3 4 5 6))
  '#(2 4 6)

                                        *vector-filter-not*
(vector-filter-not pred vec) -> vector? ~
  pred : procedure? ~
  vec : vector? ~

Like vector-filter, but the meaning of the pred predicate is reversed:
the result is a vector of all items for which pred returns #f.

Example:
  > (vector-filter-not even? #(1 2 3 4 5 6))
  '#(1 3 5)

                                        *vector-count*
(vector-count proc vec ...+) -> exact-nonnegative-integer? ~
  proc : procedure? ~
  vec : vector? ~

Returns the number of elements of the vec ... (taken in parallel) on
which proc does not evaluate to #f.

Examples:
  > (vector-count even? #(1 2 3 4 5))
  2
  > (vector-count = #(1 2 3 4 5) #(5 4 3 2 1))
  1

                                        *vector-argmin*
(vector-argmin proc vec) -> any/c ~
  proc : (-> any/c real?) ~
  vec : vector? ~

This returns the first element in the non-empty vector vec that
minimizes the result of proc.

Examples:
  > (vector-argmin car #((3 pears) (1 banana) (2 apples)))
  '(1 banana)
  > (vector-argmin car #((1 banana) (1 orange)))
  '(1 banana)

                                        *vector-argmax*
(vector-argmax proc vec) -> any/c ~
  proc : (-> any/c real?) ~
  vec : vector? ~

This returns the first element in the non-empty vector vec that
maximizes the result of proc.

Examples:
  > (vector-argmax car #((3 pears) (1 banana) (2 apples)))
  '(3 pears)
  > (vector-argmax car #((3 pears) (3 oranges)))
  '(3 pears)

                                        *vector-member*
(vector-member v lst) -> (or/c natural-number/c #f) ~
  v : any/c ~
  lst : vector? ~

Locates the first element of vec that is equal? to  v. If such an
element exists, the index of that element in  vec is returned.
Otherwise, the result is #f.

Examples:
  > (vector-member 2 (vector 1 2 3 4))
  1
  > (vector-member 9 (vector 1 2 3 4))
  #f

                                        *vector-memv*
(vector-memv v vec) -> (or/c natural-number/c #f) ~
  v : any/c ~
  vec : vector? ~

Like vector-member, but finds an element using eqv?.

Examples:
  > (vector-memv 2 (vector 1 2 3 4))
  1
  > (vector-memv 9 (vector 1 2 3 4))
  #f

                                        *vector-memq*
(vector-memq v vec) -> (or/c natural-number/c #f) ~
  v : any/c ~
  vec : vector? ~

Like vector-member, but finds an element using eq?.

Examples:
  > (vector-memq 2 (vector 1 2 3 4))
  1
  > (vector-memq 9 (vector 1 2 3 4))
  #f
