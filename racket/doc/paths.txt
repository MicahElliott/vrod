Paths

When a Racket procedure takes a filesystem path as an argument, the path
can be provided either as a string or as an instance of the path
datatype. If a string is provided, it is converted to a path using
string->path. Beware that some paths may not be representable as
strings; see Unix Path Representation and Windows Path Representation
for more information. A Racket procedure that generates a filesystem
path always generates a path value.

By default, paths are created and manipulated for the current platform,
but procedures that merely manipulate paths (without using the
filesystem) can manipulate paths using conventions for other supported
platforms. The bytes->path procedure accepts an optional argument that
indicates the platform for the path, either 'unix or 'windows. For other
functions, such as build-path or simplify-path, the behavior is
sensitive to the kind of path that is supplied. Unless otherwise
specified, a procedure that requires a path accepts only paths for the
current platform.

Two path values are equal? when they are use the same convention type
and when their byte-string representations are equal?. A path string (or
byte string) cannot be empty, and it cannot contain a nul character or
byte. When an empty string or a string containing nul is provided as a
path to any procedure except absolute-path?, relative-path?, or
complete-path?, the exn:fail:contract exception is raised.

Most Racket primitives that accept paths first cleanse the path before
using it. Procedures that build paths or merely check the form of a path
do not cleanse paths, with the exceptions of cleanse-path,
expand-user-path, and simplify-path.  For more information about path
cleansing and other platform-specific details, see Unix and Mac OS X
Paths and Windows Paths.

1. Manipulating Paths

                                        *path?*
(path? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a path value for the current platform (not a string,
and not a path for a different platform), #f otherwise.

                                        *path-string?*
(path-string? v) -> boolean? ~
  v : any/c ~

Return #t if v is either a path value for the current platform or a
non-empty string without nul characters, #f otherwise.

                                        *path-for-some-system?*
(path-for-some-system? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a path value for some platform (not a string), #f
otherwise.

                                        *string->path*
(string->path str) -> path? ~
  str : string? ~

Produces a path whose byte-string encoding is (string->bytes/locale str
(char->integer #\?)) on Unix and Mac OS X or (string->bytes/utf-8 str)
on Windows.

Beware that the current locale might not encode every string, in which
case string->path can produce the same path for different strs. See also
string->path-element, which should be used instead of string->path when
a string represents a single path element. For information on how
strings and byte strings encode paths, see Unix Path Representation and
Windows Path Representation.

See also string->some-system-path, and see Unix Path Representation and
Windows Path Representation for information on how strings encode paths.

Changed in version 6.1.1.1: Changed Windows conversion to always use
UTF-8.

                                        *bytes->path*
(bytes->path bstr [type]) -> path? ~
  bstr : bytes? ~
  type : (or/c 'unix 'windows) = (system-path-convention-type) ~

Produces a path (for some platform) whose byte-string encoding is bstr.
The optional type specifies the convention to use for the path.

For converting relative path elements from literals, use instead
bytes->path-element, which applies a suitable encoding for individual
elements.

For information on how byte strings encode paths, see Unix Path
Representation and Windows Path Representation.

                                        *path->string*
(path->string path) -> string? ~
  path : path? ~

Produces a string that represents path by decoding path’s byte-string
encoding using the current locale on Unix and Mac OS X and by using
UTF-8 on Windows. In the former case, ? is used in the result string
where encoding fails, and if the encoding result is the empty string,
then the result is "?".

The resulting string is suitable for displaying to a user,
string-ordering comparisons, etc., but it is not suitable for
re-creating a path (possibly modified) via string->path, since decoding
and re-encoding the path’s byte string may lose information.

Furthermore, for display and sorting based on individual path elements
(such as pathless file names), use path-element->string, instead, to
avoid special encodings use to represent some relative paths. See
Windows Paths for specific information about the conversion of Windows
paths.

See also some-system-path->string.

Changed in version 6.1.1.1: Changed Windows conversion to always use
UTF-8.

                                        *path->bytes*
(path->bytes path) -> bytes? ~
  path : path-for-some-system? ~

Produces path’s byte-string representation. No information is lost in
this translation, so that (bytes->path (path->bytes path)
(path-convention-type path)) always produces a path that is equal? to
path. The path argument can be a path for any platform.

Conversion to and from byte values is useful for marshaling and
unmarshaling paths, but manipulating the byte form of a path is
generally a mistake. In particular, the byte string may start with a
\\?\REL encoding for Windows paths. Instead of path->bytes, use
split-path and path-element->bytes to manipulate individual path
elements.

For information on how byte strings encode paths, see Unix Path
Representation and Windows Path Representation.

                                        *string->path-element*
(string->path-element str) -> path? ~
  str : string? ~

Like string->path, except that str corresponds to a single relative
element in a path, and it is encoded as necessary to convert it to a
path. See Unix and Mac OS X Paths and Windows Paths for more information
on the conversion of paths.

If str does not correspond to any path element (e.g., it is an absolute
path, or it can be split), or if it corresponds to an up-directory or
same-directory indicator on Unix and Mac OS X, then exn:fail:contract
exception is raised.

Like path->string, information can be lost from str in the
locale-specific conversion to a path.

                                        *bytes->path-element*
(bytes->path-element bstr [type]) -> path-for-some-system? ~
  bstr : bytes? ~
  type : (or/c 'unix 'windows) = (system-path-convention-type) ~

Like bytes->path, except that bstr corresponds to a single relative
element in a path. In terms of conversions and restrictions on bstr,
bytes->path-element is like string->path-element.

The bytes->path-element procedure is generally the best choice for
reconstructing a path based on another path (where the other path is
deconstructed with split-path and path-element->bytes) when ASCII-level
manipulation of path elements is necessary.

                                        *path-element->string*
(path-element->string path) -> string? ~
  path : path-element? ~

Like path->string, except that trailing path separators are removed (as
by split-path). On Windows, any \\?\REL encoding prefix is also removed;
see Windows Paths for more information.

The path argument must be such that split-path applied to path would
return 'relative as its first result and a path as its second result,
otherwise the exn:fail:contract exception is raised.

The path-element->string procedure is generally the best choice for
presenting a pathless file or directory name to a user.

                                        *path-element->bytes*
(path-element->bytes path) -> bytes? ~
  path : path-element? ~

Like path->bytes, except that any encoding prefix is removed, etc., as
for path-element->string.

For any reasonable locale, consecutive ASCII characters in the printed
form of path are mapped to consecutive byte values that match each
character’s code-point value, and a leading or trailing ASCII character
is mapped to a leading or trailing byte, respectively. The path argument
can be a path for any platform.

The path-element->bytes procedure is generally the right choice (in
combination with split-path) for extracting the content of a path to
manipulate it at the ASCII level (then reassembling the result with
bytes->path-element and build-path).

                                        *path<?*
(path<? a-path b-path ...) -> boolean? ~
  a-path : path? ~
  b-path : path? ~

Returns #t if the arguments are sorted, where the comparison for each
pair of paths is the same as using path->bytes and bytes<?.

                                        *path-convention-type*
(path-convention-type path) -> (or/c 'unix 'windows) ~
  path : path-for-some-system? ~

Accepts a path value (not a string) and returns its convention type.

                                        *system-path-convention-type*
(system-path-convention-type) -> (or/c 'unix 'windows) ~

Returns the path convention type of the current platform: 'unix for Unix
and Mac OS X, 'windows for Windows.

                                        *build-path*
(build-path base sub ...) -> path-for-some-system? ~
  base : (or/c path-string? path-for-some-system? 'up 'same) ~
  sub : (or/c (and/c (or/c path-string? path-for-some-system?) ~
                     (not/c complete-path?))
              (or/c 'up 'same))

Creates a path given a base path and any number of sub-path extensions.
If base is an absolute path, the result is an absolute path, otherwise
the result is a relative path.

The base and each sub must be either a relative path, the symbol 'up
(indicating the relative parent directory), or the symbol 'same
(indicating the relative current directory).  For Windows paths, if base
is a drive specification (with or without a trailing slash) the first
sub can be an absolute (driveless) path. For all platforms, the last sub
can be a filename.

The base and sub arguments can be paths for any platform. The platform
for the resulting path is inferred from the base and sub arguments,
where string arguments imply a path for the current platform. If
different arguments are for different platforms, the exn:fail:contract
exception is raised. If no argument implies a platform (i.e., all are
'up or 'same), the generated path is for the current platform.

Each sub and base can optionally end in a directory separator. If the
last sub ends in a separator, it is included in the resulting path.

If base or sub is an illegal path string (because it is empty or
contains a nul character), the exn:fail:contract exception is raised.

The build-path procedure builds a path without checking the validity of
the path or accessing the filesystem.

See Unix and Mac OS X Paths and Windows Paths for more information on
the construction of paths.

The following examples assume that the current directory is
"/home/joeuser" for Unix examples and "C:\Joe’s Files" for Windows
examples.

  (define p1 (build-path (current-directory) "src" "racket"))
   ; Unix: p1 is "/home/joeuser/src/racket" ~
   ; Windows: p1 is "C:\\Joe's Files\\src\\racket" ~
  (define p2 (build-path 'up 'up "docs" "Racket"))
   ; Unix: p2 is "../../docs/Racket" ~
   ; Windows: p2 is "..\\..\\docs\\Racket" ~
  (build-path p2 p1)
   ; Unix and Windows: raises exn:fail:contract; p1 is absolute ~
  (build-path p1 p2)
   ; Unix: is "/home/joeuser/src/racket/../../docs/Racket" ~
   ; Windows: is "C:\\Joe's Files\\src\\racket\\..\\..\\docs\\Racket" ~

                                        *build-path/convention-type*
(build-path/convention-type type          ~
                            base         
                            sub ...) -> path-for-some-system?
  type : (or/c 'unix 'windows) ~
  base : (or/c path-string? path-for-some-system? 'up 'same) ~
  sub : (or/c (and/c (or/c path-string? path-for-some-system?) ~
                     (not/c complete-path?))
              (or/c 'up 'same))

Like build-path, except a path convention type is specified explicitly.

                                        *absolute-path?*
(absolute-path? path) -> boolean? ~
  path : (or/c path-string? path-for-some-system?) ~

Returns #t if path is an absolute path, #f otherwise. The path argument
can be a path for any platform. If path is not a legal path string
(e.g., it contains a nul character), #f is returned. This procedure does
not access the filesystem.

                                        *relative-path?*
(relative-path? path) -> boolean? ~
  path : (or/c path-string? path-for-some-system?) ~

Returns #t if path is a relative path, #f otherwise. The path argument
can be a path for any platform. If path is not a legal path string
(e.g., it contains a nul character), #f is returned. This procedure does
not access the filesystem.

                                        *complete-path?*
(complete-path? path) -> boolean? ~
  path : (or/c path-string? path-for-some-system?) ~

Returns #t if path is a completely determined path (not relative to a
directory or drive), #f otherwise. The path argument can be a path for
any platform. Note that for Windows paths, an absolute path can omit the
drive specification, in which case the path is neither relative nor
complete. If path is not a legal path string (e.g., it contains a nul
character), #f is returned.

This procedure does not access the filesystem.

                                        *path->complete-path*
(path->complete-path path [base]) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~
  base : (or/c path-string? path-for-some-system?) ~
       = (current-directory)

Returns path as a complete path. If path is already a complete path, it
is returned as the result. Otherwise, path is resolved with respect to
the complete path base. If base is not a complete path, the
exn:fail:contract exception is raised.

The path and base arguments can be paths for any platform; if they are
for different platforms, the exn:fail:contract exception is raised.

This procedure does not access the filesystem.

                                        *path->directory-path*
(path->directory-path path) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~

Returns path if path syntactically refers to a directory and ends in a
separator, otherwise it returns an extended version of path that
specifies a directory and ends with a separator. For example, on Unix
and Mac OS X, the path "x/y/" syntactically refers to a directory and
ends in a separator, but "x/y" would be extended to "x/y/", and "x/.."
would be extended to "x/../". The path argument can be a path for any
platform, and the result will be for the same platform.

This procedure does not access the filesystem.

                                        *resolve-path*
(resolve-path path) -> path? ~
  path : path-string? ~

Cleanses path and returns a path that references the same file or
directory as path. If path is a soft link to another path, then the
referenced path is returned (this may be a relative path with respect to
the directory owning path), otherwise path is returned (after
expansion).

On Windows, the path for a link should be simplified syntactically, so
that an up-directory indicator removes a preceding path element
independent of whether the preceding element itself refers to a link.
For relative-paths links, the path should be parsed specially; see
Windows Paths for more information.

Changed in version 6.0.1.12: Added support for links on Windows.

                                        *cleanse-path*
(cleanse-path path) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~

Cleanses path (as described at the beginning of this chapter) without
consulting the filesystem.

                                        *expand-user-path*
(expand-user-path path) -> path? ~
  path : path-string? ~

Cleanses path. In addition, on Unix and Mac OS X, a leading ~ is treated
as user’s home directory and expanded; the username follows the ~
(before a / or the end of the path), where ~ by itself indicates the
home directory of the current user.

                                        *simplify-path*
(simplify-path path [use-filesystem?]) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~
  use-filesystem? : boolean? = #t ~

Eliminates redundant path separators (except for a single trailing
separator), up-directory .., and same-directory . indicators in path,
and changes / separators to \ separators in Windows paths, such that the
result accesses the same file or directory (if it exists) as path.

In general, the pathname is normalized as much as possible—without
consulting the filesystem if use-filesystem? is #f, and (on Windows)
without changing the case of letters within the path.  If path
syntactically refers to a directory, the result ends with a directory
separator.

When path is simplified and use-filesystem? is true (the default), a
complete path is returned. If path is relative, it is resolved with
respect to the current directory. On Unix and Mac OS X, up-directory
indicators are removed taking into account soft links (so that the
resulting path refers to the same directory as before); on Windows,
up-directory indicators are removed by by deleting a preceding path
element.

When use-filesystem? is #f, up-directory indicators are removed by
deleting a preceding path element, and the result can be a relative path
with up-directory indicators remaining at the beginning of the path;
up-directory indicators are dropped when they refer to the parent of a
root directory. Similarly, the result can be the same as (build-path
'same) (but with a trailing separator) if eliminating up-directory
indicators leaves only same-directory indicators.

The path argument can be a path for any platform when use-filesystem? is
#f, and the resulting path is for the same platform.

The filesystem might be accessed when use-filesystem? is true, but the
source or simplified path might be a non-existent path. If path cannot
be simplified due to a cycle of links, the exn:fail:filesystem exception
is raised (but a successfully simplified path may still involve a cycle
of links if the cycle did not inhibit the simplification).

See Unix and Mac OS X Paths and Windows Paths for more information on
simplifying paths.

                                        *normal-case-path*
(normal-case-path path) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~

Returns path with “normalized” case letters. For Unix and Mac OS X
paths, this procedure always returns the input path, because filesystems
for these platforms can be case-sensitive. For Windows paths, if path
does not start \\?\, the resulting string uses only lowercase letters,
based on the current locale. In addition, for Windows paths when the
path does not start \\?\, all /s are converted to \s, and trailing
spaces and .s are removed.

The path argument can be a path for any platform, but beware that
local-sensitive decoding and conversion of the path may be different on
the current platform than for the path’s platform.

This procedure does not access the filesystem.

                                        *split-path*
(split-path path) -> (or/c path-for-some-system? 'relative #f) ~
                     (or/c path-for-some-system? 'up 'same)
                     boolean?
  path : (or/c path-string? path-for-some-system?) ~

Deconstructs path into a smaller path and an immediate directory or file
name.  Three values are returned:

* base is either

  * a path,

  * 'relative if path is an immediate relative directory or filename, or

  * #f if path is a root directory.

* name is either

  * a directory-name path,

  * a filename,

  * 'up if the last part of path specifies the parent directory of the
    preceding path (e.g., .. on Unix), or

  * 'same if the last part of path specifies the same directory as the
    preceding path (e.g., . on Unix).

* must-be-dir? is #t if path explicitly specifies a directory (e.g.,
  with a trailing separator), #f otherwise. Note that must-be-dir? does
  not specify whether name is actually a directory or not, but whether
  path syntactically specifies a directory.

Compared to path, redundant separators (if any) are removed in the
result base and name.  If base is #f, then name cannot be 'up or 'same.
The path argument can be a path for any platform, and resulting paths
for the same platform.

This procedure does not access the filesystem.

See Unix and Mac OS X Paths and Windows Paths for more information on
splitting paths.

                                        *explode-path*
(explode-path path) ~
 -> (listof (or/c path-for-some-system? 'up 'same))
  path : (or/c path-string? path-for-some-system?) ~

Returns the list of path elements that constitute path.  If path is
simplified in the sense of simple-form-path, then the result is always a
list of paths, and the first element of the list is a root.

The explode-path function computes its result in time proportional to
the length of path (unlike a loop in that uses split-path, which must
allocate intermediate paths).

                                        *path-replace-suffix*
(path-replace-suffix path suffix) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~
  suffix : (or/c string? bytes?) ~

Returns a path that is the same as path, except that the suffix for the
last element of the path is changed to suffix. If the last element of
path has no suffix, then suffix is added to the path. A suffix is
defined as a . followed by any number of non-. characters/bytes at the
end of the path element, as long as the path element is not ".." or ".".
The path argument can be a path for any platform, and the result is for
the same platform. If path represents a root, the exn:fail:contract
exception is raised.

                                        *path-add-suffix*
(path-add-suffix path suffix) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~
  suffix : (or/c string? bytes?) ~

Similar to path-replace-suffix, but any existing suffix on path is
preserved by replacing every . in the last path element with _, and then
the suffix is added to the end.

                                        *reroot-path*
(reroot-path path root-path) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~
  root-path : (or/c path-string? path-for-some-system?) ~

Produces a path that extends root-path based on the complete form of
path.

If path is not already complete, is it completed via
path->complete-path, in which case path must be a path for the current
platform. The path argument is also cleansed and case-normalized via
normal-case-path. The path is then appended to root-path; in the case of
Windows paths, a root letter drive becomes a letter path element, while
a root UNC path is prefixed with "UNC" as a path element and the machine
and volume names become path elements.

Examples:
  > (reroot-path (bytes->path #"/home/caprica/baltar" 'unix)
                 (bytes->path #"/earth" 'unix))
  #<path:/earth/home/caprica/baltar>
  > (reroot-path (bytes->path #"c:\\usr\\adama" 'windows) ~
                 (bytes->path #"\\\\earth\\africa\\" 'windows))
  #<windows-path:\\earth\africa\c\usr\adama>
  > (reroot-path (bytes->path #"\\\\galactica\\cac\\adama" 'windows)
                 (bytes->path #"s:\\earth\\africa\\" 'windows)) ~
  #<windows-path:s:\earth\africa\UNC\galactica\cac\adama>

2. More Path Utilities

 (require racket/path) package: base ~

The bindings documented in this section are provided by the racket/path
and racket libraries, but not racket/base.

                                        *file-name-from-path*
(file-name-from-path path) -> (or/c path-for-some-system? #f) ~
  path : (or/c path-string? path-for-some-system?) ~

Returns the last element of path. If path is syntactically a directory
path (see split-path), then the result is #f.

                                        *filename-extension*
(filename-extension path) -> (or/c bytes? #f) ~
  path : (or/c path-string? path-for-some-system?) ~

Returns a byte string that is the extension part of the filename in path
without the . separator. If path is syntactically a directory (see
split-path) or if the path has no extension, #f is returned.

                                        *find-relative-path*
(find-relative-path  base                                 ~
                     path                                
                    [#:more-than-root? more-than-root?])  ~
 -> path-for-some-system?
  base : (or/c path-string? path-for-some-system?) ~
  path : (or/c path-string?  path-for-some-system?) ~
  more-than-root? : any/c = #f ~

Finds a relative pathname with respect to base that names the same file
or directory as path. Both base and path must be simplified in the sense
of simple-form-path.  If path shares no subpath in common with base,
path is returned.

If more-than-root? is true, if base and path share only a Unix root in
common, and if neither base nor path is just a root path, then path is
returned.

                                        *normalize-path*
(normalize-path path [wrt]) -> path? ~
  path : path-string? ~
  wrt : (and/c path-string? complete-path?) ~
      = (current-directory)

For most purposes, simple-form-path is the preferred mechanism to
normalize a path, because it works for paths that include non-existent
directory components, and it avoids unnecessarily expanding soft links.

Returns a complete version of path by making the path complete,
expanding the complete path, and resolving all soft links (which
requires consulting the filesystem). If path is relative, then wrt is
used as the base path.

Letter case is not normalized by normalize-path. For this and other
reasons, such as whether the path is syntactically a directory, the
result of normalize-path is not suitable for comparisons that determine
whether two paths refer to the same file or directory (i.e., the
comparison may produce false negatives).

An error is signaled by normalize-path if the input path contains an
embedded path for a non-existent directory, or if an infinite cycle of
soft links is detected.

                                        *path-element?*
(path-element? path) -> boolean? ~
  path : any/c ~

Returns #t if path is a path element: a path value for some platform
(see path-for-some-system?) such that split-path applied to path would
return 'relative as its first result and a path as its second result.
Otherwise, the result is #f.

                                        *path-only*
(path-only path) -> (or/c #f path-for-some-system?) ~
  path : (or/c path-string? path-for-some-system?) ~

If path is a filename, the file’s path is returned. If path is
syntactically a directory, path is returned (as a path, if it was a
string). If path has no directory part #f is returned.

                                        *simple-form-path*
(simple-form-path path) -> path? ~
  path : path-string? ~

Returns (simplify-path (path->complete-path path)), which ensures that
the result is a complete path containing no up- or same-directory
indicators.

                                        *some-system-path->string*
(some-system-path->string path) -> string? ~
  path : path-for-some-system? ~

Converts path to a string using a UTF-8 encoding of the path’s bytes.

Use this function when working with paths for a different system (whose
encoding of pathnames might be unrelated to the current locale’s
encoding) and when starting and ending with strings.

                                        *string->some-system-path*
(string->some-system-path str kind) -> path-for-some-system? ~
  str : string? ~
  kind : (or/c 'unix 'windows) ~

Converts str to a kind path using a UTF-8 encoding of the path’s bytes.

Use this function when working with paths for a different system (whose
encoding of pathnames might be unrelated to the current locale’s
encoding) and when starting and ending with strings.

                                        *shrink-path-wrt*
(shrink-path-wrt pth other-pths) -> (or/c #f path?) ~
  pth : path? ~
  other-pths : (listof path?) ~

Returns a suffix of pth that shares nothing in common with the suffixes
of other-pths, or pth, if not possible (e.g. when other-pths is empty or
contains only paths with the same elements as pth).

Examples:
  > (shrink-path-wrt (build-path "racket" "list.rkt")
                     (list (build-path "racket" "list.rkt")
                           (build-path "racket" "base.rkt")))
  #<path:list.rkt>
  > (shrink-path-wrt (build-path "racket" "list.rkt")
                     (list (build-path "racket" "list.rkt")
                           (build-path "racket" "private" "list.rkt")
                           (build-path "racket" "base.rkt")))
  #<path:racket/list.rkt>

3. Unix and Mac OS X Paths

In a path on Unix and Mac OS X, a / separates elements of the path, . as
a path element always means the directory indicated by preceding path,
and .. as a path element always means the parent of the directory
indicated by the preceding path. A leading ~ in a path is not treated
specially, but expand-user-path can be used to convert a leading ~
element to a user-specific directory. No other character or byte has a
special meaning within a path. Multiple adjacent / are equivalent to a
single / (i.e., they act as a single path separator).

A path root is always /. A path starting with / is an absolute, complete
path, and a path starting with any other character is a relative path.

Any pathname that ends with a / syntactically refers to a directory, as
does any path whose last element is . or ...

A Unix and Mac OS X path is cleansed by replacing multiple adjacent /s
with a single /.

For (bytes->path-element bstr), bstr must not contain any /, otherwise
the exn:fail:contract exception is raised. The result of
(path-element->bytes path) or (path-element->string path) is always the
same as the result of (path->bytes path) and (path->string path). Since
that is not the case for other platforms, however, path-element->bytes
and path-element->string should be used when converting individual path
elements.

On Mac OS X, Finder aliases are zero-length files.

3.1. Unix Path Representation

A path on Unix and Mac OS X is natively a byte string. For presentation
to users and for other string-based operations, a path is converted
to/from a string using the current locale’s encoding with ? (encoding)
or #\uFFFD (decoding) in place of errors. Beware that the encoding may
not accommodate all possible paths as distinct strings.

4. Windows Paths

In general, a Windows pathname consists of an optional drive specifier
and a drive-specific path. A Windows path can be absolute but still
relative to the current drive; such paths start with a / or \ separator
and are not UNC paths or paths that start with \\?\.

A path that starts with a drive specification is complete. Roughly, a
drive specification is either a Latin letter followed by a colon, a UNC
path of the form \\>machine<\>volume<, or a \\?\ form followed by
something other than REL\>element<, or RED\>element<. (Variants of \\?\
paths are described further below.)

Racket fails to implement the usual Windows path syntax in one way.
Outside of Racket, a pathname "C:rant.txt" can be a drive-specific
relative path. That is, it names a file "rant.txt" on drive "C:", but
the complete path to the file is determined by the current working
directory for drive "C:". Racket does not support drive-specific working
directories (only a working directory across all drives, as reflected by
the current-directory parameter). Consequently, Racket implicitly
converts a path like "C:rant.txt" into "C:\rant.txt".

* Racket-specific: Whenever a path starts with a drive specifier
  >letter<: that is not followed by a / or \, a \ is inserted as the
  path is cleansed.

Otherwise, Racket follows standard Windows path conventions, but also
adds \\?\REL and \\?\RED conventions to  deal with paths inexpressible
in the standard convention, plus  conventions to deal with excessive \s
in \\?\  paths.

In the following, >letter< stands for a Latin letter (case does not
matter), >machine< stands for any sequence of characters that does not
include \ or / and is not ?, >volume< stands for any sequence of
characters that does not include \ or / , and >element< stands for any
sequence of characters that does not include \.

* Trailing spaces and . in a path element are ignored when the element
  is the last one in the path, unless the path starts with \\?\ or the
  element consists of only spaces and .s.

* The following special “files”, which access devices, exist in all
  directories, case-insensitively, and with all possible endings after a
  period or colon, except in pathnames that start with \\?\: "NUL",
  "CON", "PRN", "AUX", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6",
  "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5",
  "LPT6", "LPT7", "LPT8", "LPT9".

* Except for \\?\ paths, /s are equivalent to \s. Except for \\?\ paths
  and the start of UNC paths, multiple adjacent /s and \s count as a
  single \. In a path that starts \\?\ paths, elements can be separated
  by either a single or double \.

* A directory can be accessed with or without a trailing separator. In
  the case of a non-\\?\ path, the trailing separator can be any number
  of /s and \s; in the case of a \\?\ path, a trailing separator must be
  a single \, except that two \s can follow \\?\>letter<:.

* Except for \\?\ paths, a single . as a path element means “the current
  directory,” and a .. as a path element means “the parent directory.”
  Up-directory path elements (i.e., ..) immediately after a drive are
  ignored.

* A pathname that starts \\>machine<\>volume< (where a / can replace any
  \) is a UNC path, and the starting \\>machine<\>volume< counts as the
  drive specifier.

* Normally, a path element cannot contain a character in the range #\x 0
  to #\x 1F nor any of the following characters:

  < > : " / \ |

  Except for \, path elements containing these characters can be
  accessed using a \\?\ path (assuming that the underlying filesystem
  allows the characters).

* In a pathname that starts \\?\>letter<:\, the \\?\>letter<:\ prefix
  counts as the path’s drive, as long as the path does not both contain
  non-drive elements and end with two consecutive \s, and as long as the
  path contains no sequence of three or more \s. Two \s can appear in
  place of the \ before >letter<. A / cannot be used in place of a \
  (but /s can be used in element names, though the result typically does
  not name an actual directory or file).

* In a pathname that starts \\?\UNC\>machine<\>volume<, the
  \\?\UNC\>machine<\>volume< prefix counts as the path’s drive, as long
  as the path does not end with two consecutive \s, and as long as the
  path contains no sequence of three or more \s. Two \s can appear in
  place of the \ before UNC, the \s after UNC, and/or the \s
  after>machine<.  The letters in the UNC part can be uppercase or
  lowercase, and / cannot be used in place of \s (but / can be used in
  element names).

* Racket-specific: A pathname that starts \\?\REL\>element< or
  \\?\REL\\>element< is a relative path, as long as the path does not
  end with two consecutive \s, and as long as the path contains no
  sequence of three or more \s. This Racket-specific path form supports
  relative paths with elements that are not normally expressible in
  Windows paths (e.g., a final element that ends in a space). The REL
  part must be exactly the three uppercase letters, and /s cannot be
  used in place of \s. If the path starts \\?\REL\..  then for as long
  as the path continues with repetitions of \.., each element counts as
  an up-directory element; a single \ must be used to separate the
  up-directory elements. As soon as a second \ is used to separate the
  elements, or as soon as a non-..  element is encountered, the
  remaining elements are all literals (never up-directory elements).
  When a \\?\REL path value is converted to a string (or when the path
  value is written or displayed), the string does not contain the
  starting \\?\REL or the immediately following \s; converting a path
  value to a byte string preserves the \\?\REL prefix.

* Racket-specific: A pathname that starts \\?\RED\>element< or
  \\?\RED\\>element< is a drive-relative path, as long as the path does
  not end with two consecutive \s, and as long as the path contains no
  sequence of three or more \s. This Racket-specific path form supports
  drive-relative paths (i.e., absolute given a drive) with elements that
  are not normally expressible in Windows paths. The RED part must be
  exactly the three uppercase letters, and /s cannot be used in place of
  \s. Unlike \\?\REL paths, a .. element is always a literal path
  element. When a \\?\RED path value is converted to a string (or when
  the path value is written or displayed), the string does not contain
  the starting \\?\RED and it contains a single starting \; converting a
  path value to a byte string preserves the \\?\RED prefix.

Three additional Racket-specific rules provide meanings to character
sequences that are otherwise ill-formed as Windows paths:

* Racket-specific: In a pathname of the form \\?\>any<\\ where >any< is
  any non-empty sequence of characters other than >letter<: or
  \>letter<:, the entire path counts as the path’s (non-existent) drive.

* Racket-specific: In a pathname of the form \\?\>any<\\\>elements<,
  where >any< is any non-empty sequence of characters and >elements< is
  any sequence that does not start with a \, does not end with two \s,
  and does not contain a sequence of three \s, then \\?\>any<\\ counts
  as the path’s (non-existent) drive.

* Racket-specific: In a pathname that starts \\?\ and does not match any
  of the patterns from the preceding bullets, \\?\ counts as the path’s
  (non-existent) drive.

Outside of Racket, except for \\?\ paths, pathnames are  typically
limited to 259 characters. Racket internally converts  pathnames to \\?\
form as needed to avoid this  limit. The operating system cannot access
files through  \\?\ paths that are longer than 32,000 characters or  so.

Where the above descriptions says “character,” substitute “byte” for
interpreting byte strings as paths. The encoding of Windows paths into
bytes preserves ASCII characters, and all special characters mentioned
above are ASCII, so all of the rules are the same.

Beware that the \ path separator is an escape character in Racket
strings. Thus, the path \\?\REL\..\\..  as a string must be written
"\\\\?\\REL\\..\\\\..".

A path that ends with a directory separator syntactically refers to a
directory.  In addition, a path syntactically refers to a directory if
its last element is a same-directory or up-directory indicator (not
quoted by a \\?\ form), or if it refers to a root.

Even on variants of Windows that support symbolic links, up-directory ..
indicators in a path are resolved syntactically, not sensitive to links.
For example, if a path ends with d\..\f and d refers to a symbolic link
that references a directory with a different parent than d, the path
nevertheless refers to f in the same directory as d. A relative-path
link is parsed as if prefixed with \\?\REL paths, except that ..  and .
elements are allowed throughout the path, and any number of redundant /
separators are allowed.

Windows paths are cleansed as follows: In paths that start \\?\,
redundant \s are removed, an extra \ is added in a \\?\REL if an extra
one is not already present to separate up-directory indicators from
literal path elements, and an extra \ is similarly added after \\?\RED
if an extra one is not already present. For other paths, multiple /s and
\s are converted to single /s or \ (except at the beginning of a shared
folder name), and a \ is inserted after the colon in a drive
specification if it is missing.

For (bytes->path-element bstr), /s, colons, trailing dots, trailing
whitespace, and special device names (e.g., “aux”) in bstr are encoded
as a literal part of the path element by using a \\?\REL prefix.  The
bstr argument must not contain a \, otherwise the exn:fail:contract
exception is raised.

For (path-element->bytes path) or (path-element->string path), if the
byte-string form of path starts with a \\?\REL, the prefix is not
included in the result.

For (build-path base-path sub-path ...), trailing spaces and periods are
removed from the last element of base-path and all but the last sub-path
(unless the element consists of only spaces and periods), except for
those that start with \\?\. If base-path starts \\?\, then after each
non-\\?\REL\ and non-\\?\RED\ sub-path is added, all /s in the addition
are converted to \s, multiple consecutive \s are converted to a single
\, added . elements are removed, and added .. elements are removed along
with the preceding element; these conversions are not performed on the
original base-path part of the result or on any \\?\REL\ or \\?\RED\ or
sub-path.  If a \\?\REL\ or \\?\RED\ sub-path is added to a non-\\?\
base-path, the base-path (with any additions up to the \\?\REL\ or
\\?\RED\ sub-path) is simplified and converted to a \\?\ path.  In other
cases, a \ may be added or removed before combining paths to avoid
changing the root meaning of the path (e.g., combining //x and y
produces /x/y, because //x/y would be a UNC path instead of a
drive-relative path).

For (simplify-path path use-filesystem?), path is expanded, and if path
does not start with \\?\, trailing spaces and periods are removed, a /
is inserted after the colon in a drive specification if it is missing,
and a \ is inserted after \\?\ as a root if there are elements and no
extra \ already. Otherwise, if no indicators or redundant separators are
in path, then path is returned.

For (split-path path) producing base, name, and must-be-dir?, splitting
a path that does not start with \\?\ can produce parts that start with
\\?\. For example, splitting C:/x~/aux/ produces \\?\C:\x~\ and
\\?\REL\\aux; the \\?\ is needed in these cases to preserve a trailing
space after x and to avoid referring to the AUX device instead of an
"aux" file.

4.1. Windows Path Representation

A path on Windows is natively a sequence of UTF-16 code units, where the
sequence can include unpaired surrogates. This sequence is encoded as a
byte string through an extension of UTF-8, where unpaired surrogates in
the UTF-16 code-unit sequence are converted as if they were
non-surrogate values. The extended encodings are implemented on Windows
as the "platform-UTF-16" and "platform-UTF-8" encodings for
bytes-open-converter.

Racket’s internal representation of a Windows path is a byte string, so
that path->bytes and bytes->path are always inverses. When converting a
path to a native UTF-16 code-unit sequence, #\tab is used in place of
platform-UTF-8 decoding errors (on the grounds that tab is normally
disallowed as a character in a Windows path, unlike #\uFFFD).

A Windows path is converted to a string by treating the platform-UTF-8
encoding as a UTF-8 encoding with #\uFFFD in place of decoding errors.
Similarly, a string is converted to a path by UTF-8 encoding (in which
case no errors are possible).
